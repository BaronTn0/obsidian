## Tools and environment setup

We will be doing this analysis in a Windows 10 VM with the [flare-vm](https://github.com/mandiant/flare-vm) tools installed. Most of the tools listed below will come with flare-vm by default.

-   [CFF Explorer](https://ntcore.com/?page_id=388) - Good tool to gloss through basic PE information
-   [dnSpy](https://github.com/dnSpy/dnSpy) - For reversing .NET binaries
-   [HxD](https://mh-nexus.de/en/hxd/) - Pretty good hex editor for windows
-   [IDA Pro](https://hex-rays.com/ida-pro/) - A must have. While the decompiler is not strictly necessary, it can make life much easier and we'll be using it extensively here
-   [Python 3](https://www.python.org/) - Our weapon of choice. We'll also need to install some packages using the following [pip](https://pip.pypa.io/en/stable/) command

```
pip install Pillow numpy pefile pycryptodome
```

-   [Powershell](https://docs.microsoft.com/en-us/powershell/) - Comes with windows by default. While we can survive with just python, some actions involving the OS (e.g. listing files) are so much more simple in powershell

## Initial analysis

The [crackme](https://blog.malwarebytes.com/threat-intelligence/2021/10/the-return-of-the-malwarebytes-crackme/) is an executable called `MBCrackme.exe`.

アプリケーションを実行すると、次のようなGUIが表示されます。3種類のパスワードを入力するテキストフィールドと "Check!"と書かれたボタンを持つフォームがあります。

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_0.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_0.png)

CFFエクスプローラで開いてみると、ファイルタイプは.NETアセンブリで、.NETディレクトリというディレクトリが含まれていて、これが.NETバイナリであることがわかります。

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_1.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_1.png)

つまり、dnSpyでバイナリを解析すれば、バイナリの中のC#コードを見ることができるということです。幸運なことに、コード内の変数は適切に命名されており、難読化されていません。

Form1クラスの下には、button1_Click(object, EventArgs)、button2_Click(object, EventArgs)、button3_Click(object, EventArgs)という3つの重要なメソッドがあり、これらは対応するフォームボタンがクリックされたときに呼び出されます。

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_2.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_2.png)

したがって、このcrackmeチャレンジは3つのレベルに分けられ、それぞれのレベルは見つけるべきパスワードに対応しています。

## Level 1

最初のパスワードを見つけるためには、最初のボタンがクリックされたときに呼び出されるメソッド、`button1_Click(object sender, EventArgs e)`を調べるのがよいでしょう。

private void button1\_Click(object sender, EventArgs e)
{
if (this.textBox1.Text.Length \== 0)
{
MessageBox.Show("Enter the password!");
return;
}

送信されたパスワードが空白ではないことを確認した後（これは他の2つのボタンクリックメソッドにもあります）、同じクラスの`decode(Bitmap, string)`メソッドを呼び出し、引数として、実際にフォームGUIで表示される背景画像である`mb_logo_star`というリソースと、フォームに入力された最初のパスワードを渡します。

// continued from button1\_Click...
bool flag \= false;
string text \= this.textBox1.Text;
byte\[\] array \= Form1.decode(Resources.mb\_logo\_star, text);

このメソッドは、ビットマップ引数のRGBピクセルをカラムメジャー順に繰り返し、各ピクセルごとにR、G、Bの各チャンネルから最下位の数ビットを取り出し、それらを1つのバイト`b`に結合し、`b`と引数の`password_str`からのバイトをXORして、すべてのピクセルに適用した結果をバイト配列として返します。これはビットマップ[ステガノグラフィ](https://www.comptia.org/blog/what-is-steganography)の一形態で、単純な繰り返し鍵で暗号化されたペイロードを隠すために使用されます[XOR暗号](https://en.wikipedia.org/wiki/XOR_cipher)。

public static byte\[\] decode(Bitmap bm, string password\_str)
{
byte\[\] bytes \= Encoding.ASCII.GetBytes(password\_str);
byte\[\] array \= new byte\[bm.Width \* bm.Height\];
int num \= 0;
for (int i \= 0; i < bm.Width; i++)
{
for (int j \= 0; j < bm.Height; j++)
{
Color pixel \= bm.GetPixel(i, j);
int num2 \= Form1.keep\_bits((int)pixel.R, 3);
int num3 \= Form1.keep\_bits((int)pixel.G, 3) << 3;
int num4 \= Form1.keep\_bits((int)pixel.B, 2) << 6;
byte b \= (byte)(num2 | num3 | num4);
if (bytes.Length != 0)
{
b ^= bytes\[num % bytes.Length\];
}
array\[num\] \= b;
num++;
}
}
return array;
}

decode() メソッドを呼び出し、リソースからデコードされたバイト配列を取得した後、オリジナルの `button1_Click()` メソッドは、配列が 241152 である `Form1.validSize_1` よりも大きい場合には配列を切り詰め、切り詰められた配列の CRC32 チェックサムを計算して、`Form1.validCrc32_1` と比較します。

// continued from button1\_Click...
if (array.Length \> Form1.validSize\_1)
{
Array.Resize<byte\>(ref array, Form1.validSize\_1);
}
if (Crc32Algorithm.Compute(array) \== Form1.validCrc32\_1)
{
flag \= true;
try
{
if (Form1.g\_serverProcess \== null || Form1.g\_serverProcess.HasExited)
{
File.WriteAllBytes(this.g\_serverPath, array);
flag \= this.runProcess(this.g\_serverPath);
}
}
// Exception handling and form GUI adjustments...

そして，CRC32のハッシュが一致した場合には，デコードされたバイト配列をディスク上のファイル（パスは`this.g_serverPath`）にダンプします．`this.g_serverPath`の定義を見てみると、作成されるファイルは`level2.exe`という名前で、tempディレクトリに置かれていることが分かります。

private string g\_serverPath \= Path.Combine(Path.GetTempPath(), "level2.exe");

そして、そのパスでメソッド`runProcess(string)`を呼び出し、与えられた引数のパスにある実行ファイルから隠しウィンドウプロセスを起動しています。

private bool runProcess(string path)
{
if (Form1.g\_serverProcess != null)
{
if (!Form1.g\_serverProcess.HasExited)
{
Form1.g\_serverProcess.Kill();
}
Form1.g\_serverProcess.Close();
}
bool result \= false;
try
{
Process process \= new Process();
process.StartInfo.FileName \= path;
process.StartInfo.WindowStyle \= ProcessWindowStyle.Hidden;
result \= process.Start();
Form1.g\_serverProcess \= process;
}
catch (Exception)
{
}
return result;
}

これまでにわかっていることをまとめると

1.  パスワードで（リソース画像に埋め込まれた）暗号文を実行ファイルにXOR復号化する
2.  この復号化された実行ファイルのCRC32チェックサムは`0xA367C374`である。

そして、私たちは以下のことを知りません。

1.  パスワードの長さ
2.  どのような文字がパスワードを構成しているか

次のいくつかのセクションでは、パスワードを回復するためのさまざまな方法について説明します。


### Brute force attack

明白な方法は、パスワードを[brute force](https://en.wikipedia.org/wiki/Brute-force_attack)してみることです。これは、パスワードの異なる値を試し、CRC32チェックサムを`0xA367C374`と比較することで、復号されたペイロードが正しいかどうかを検証します。

前述のように、パスワードの文字セットや長さはわかりませんが、いくつかの妥当な推測ができます。デコードメソッドで使用される前に、テキストボックスにパスワードを入力しなければならないことがわかっているので、パスワードはおそらく[printable ASCII characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters)で構成されているでしょう。長さについては、一致する長さのパスワードが見つかるまで、さまざまな値を試してみることができます。

まず、画像から暗号文を抽出する必要があります。まず、リソースを抽出する必要があります。ここでは、`mb_logo_star.png`と呼びます。

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_3.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_3.png)

そして、XORを行わずに抽出方法を再実装することで、暗号文を得ることができます。

from PIL import Image
import numpy as np

def extract\_data(image):
  newarray \= \[\]
  num \= 0
  for j in range(len(image\[0\])):
      for i in range(len(image)):
          r \= (0b00000111 & image\[i\]\[j\]\[0\])
          g \= (0b00000111 & image\[i\]\[j\]\[1\]) << 3
          b \= (0b00000011 & image\[i\]\[j\]\[2\]) << 6
          newarray.append(r | g | b)
  return bytes(newarray)

image \= np.asarray(Image.open('mb\_logo\_star.png')) \# 700 x 700 x 3
ciphertext \= extract\_data(image)\[:241152\]

これで、抽出された暗号文が変数 `ciphertext` に格納されました。また，XOR暗号を実装したいと思います。

def xor(data, key):
    return bytes(\[b ^ key\[i % len(key)\] for i, b in enumerate(data)\])

これで、ブルートフォースアタックを開始するのに必要なものが揃いました。

import zlib
import string
import itertools

CHARSET \= string.printable

for length in range(1, 50):
    print(f"Trying length {length}...")
    attempts \= itertools.product(CHARSET, repeat\=length)
    for attempt in attempts:
        key \= bytes(attempt)
        if zlib.crc32(xor(ciphertext, key)) \== 0xA367C374:
            print(f"Found password! {key}")

しかし、実際に実行してみると、長さ3のパスワードを試すのがやっとで、スクリプトが動かなくなってしまうことがわかります。

これにはいくつかの要因があります。まず、暗号文は241152バイトと巨大なので、パスワードを入力するたびに、「xor(ciphertext, key)」を呼び出すたびに、多くの処理が必要になります。次に、より差し迫った問題として、検索空間がパスワードの長さに応じて指数関数的に増大することが挙げられます。印刷可能なASCII文字は100個あるので（これは`len(string.printable)`で調べることができます）、新しい文字を追加するたびに、新しい検索空間は100倍になるということです。後で分かったことですが、パスワードの長さは実際には49文字だったので、49の100乗（1の後に0が98個続く）のパスワードを試さなければならなかったことになります。これは「観測可能な宇宙の原子の数」(https://www.liverpoolmuseums.org.uk/stories/which-greater-number-of-atoms-universe-or-number-of-chess-moves)よりも数桁大きい数字です。

つまり、ブルートフォースはダメで、他の方法を試すべきだということです。

### Leaked key in ciphertext

一歩下がって、暗号文に何か手掛かりがないか見てみるのも良いアイデアです。以前、ブルートフォースで暗号文を取得する際に書いたコードを再利用し、最初の数バイトをダンプして、何か作業できることがないかを確認します。

\>>\> ciphertext\[:100\]
b'(;\\xe3y\\\\leval\_o\\x91\\x9a\_a\\xd4most\_do.e\_xor\_pe\_and\_keep\_going!easy\_level\_\\x97ne\_os\\xd7as\\xc0V\\xa9N\\xd6d\\x13\\xb5N&7\\x19\\x16\\x7f\\x11\\x1c\\x0b8\\x19\\x04\\x08P<\\x06\\x01\\x07\\x01\\x13\\x01\\x07\\x04'
\>>\> ciphertext\[:1000\]
b"(;\\xe3y\\\\leval\_o\\x91\\x9a\_a\\xd4most\_do.e\_xor\_pe\_and\_keep\_going!easy\_level\_\\x97ne\_os\\xd7as\\xc0V\\xa9N\\xd6d\\x13\\xb5N&7\\x19\\x16\\x7f\\x11\\x1c\\x0b8\\x19\\x04\\x08P<\\x06\\x01\\x07\\x01\\x13\\x01\\x07\\x04S\\x0b\*\\x02E\\x1f\\x0bL\\x1b =E2\\x0e\\x08\\x08A~yU@one\_xor\\xfb\\x9b\\xdeL\\x81\\xe4\\xb1\\x1f\\x8b\\xef\\xb00\\xbf\\xed\\xba)\\xeb\\x8b\\xf7$\\x8b\\xf9\\xac\\x1f\\xe9\\x89\\xa6$\\x07\\xd5\\xba.\\xe0\\xb3\\xb0\-\\x9f\\xe5\\xa64\\xed\\x86\\xbf/\\xa1\\xd5\\xad/\\xc0\\xbd\\xa1$\\xae\\xeb\\xbb$\\xed\\x89\\xb3$\\x81\\xd5\\xb2/\\xec\\x82\\xb3\`\\x80\\xeb\\xa69\\xbf\\xe6\\xb16\\xd7\\xe6\\x8a/\*\\x86\\x8f \\x88\\xe7\\xba30\\xbcN/\\x8f\\xef\\x8a8+\\x91\\x881\\x84\\xd5\\xb4.66\\x08\\r\\x85\\xfa\\x8a'oing!eas)\\x1ale:di\_\\x80Mu>almost\_d\\x8fng^sn|Op\\xa7\_an\\x96\]keep\_\\x14zing1eas\\x99\_lev%l\_\\x7fne\_clmist\_doneYxor\_pe\_a\\x9eg\_kaep\_goilga\\xe4asi\_luvel\_\\x7fneOalmostOdone\_xor\_pesSodckeep\\x8fdo\\x89og!easy\_level\_one\_al\\x8dlslQdonN^xsr\_pe\_and\_keep\_going!easy\_leVNm\_/ne\_almost\_do\\x8ee\_lnr\_pe\_and\_keep\_going!easy\_lK\\x02\\x00\\x14+one\\xd8\\xa1lmoct\_d\\xadne\_|or\_pe\_and\_keep\\x7fgo\\t@\\x15E\\x04\\x15\\x12y\_\\x1a\=vel\\xbfone\\x05alm\\xa9st\_done\_xor\_pe\\x1fan$q\\x0f\\x04\\x11\\x11\_go}\\xebe!e!ry\_\\x10gveL^one\_almost\_do.e\_\\xb8A\\x00,\\x02\\x06\_an\\x84^kee\\xa0\\\\gokng!\\xf9bsy\_level\_one\_!lm/\]\\x06:\\x08\\x00\\re\_\`ar\_p\\x85\\\\ant\_ke\\xfbs\_going!easy\_l%ve.\_one\_almost\_done\_xor\_pe\_and\_keep\_going!easy\_level\_one\_almost\_done\_xor\_pe\_and\_keep\_going!easy\_level\_one\_almost\_done\_xor\_pe\_and\_keep\_going!easy\_level\_one\_almost\_done\_xor\_pe\_and\_keep\_going!easy\_level\_one\_almost\_done\_xor\_pe\_and\_keep\_going!easy\_level\_one\_almost\_done\_xor\_pe\_and\_keep\_going!easy\_level\_one\_almos"

`easy_level_one_almost_done_xor_pe_and_keep_going!`という文字列が何度も繰り返されているのがわかります。これは、平文に大きなブロックのNULLバイトが含まれているためで、これでは暗号文の鍵が漏れてしまいます。これは、「平文 XOR キー = 暗号文」だからで、平文が0ならば、「暗号文 = 0 XOR キー = キー」となります。繰り返しの部分は、暗号の中で鍵が繰り返されていることに由来します。そのため、平文の大きなブロックにヌルバイトの大きなブロックが含まれている場合（これは非常によくあることです）、平文の中で鍵が繰り返されているのを見ることができるのです。

そこで，キーとして`easy_level_one_almost_done_xor_pe_and_keep_going!`を試してみると，復号後の平文が正しいCRC32ハッシュを持っていることがわかります。

\>>\> hex(zlib.crc32(xor(ciphertext, b"easy\_level\_one\_almost\_done\_xor\_pe\_and\_keep\_going!")))
'0xa367c374'

### Known plaintext attack

すでに鍵を持っていても、学習のために別の復号化の方法を模索することができます。

復号されたファイルが実行ファイルであることがわかっているので、復号された平文がどのようなものであるかの情報があり、[known plaintext attack](https://en.wikipedia.org/wiki/Known-plaintext_attack)を使ってXORキーを取得しようとすることができます。

このXOR暗号の既知の平文攻撃の脆弱性は、[そのWikipediaの項目](https://en.wikipedia.org/wiki/XOR_cipher)に記載されています。

> これらの暗号では、_plaintext_⊕_ciphertext_ = _key_ であるため、XOR演算子は known-plaintext 攻撃に対して脆弱です。

Windowsの実行ファイルは、[Portable Executable (PE) format](https://en.wikipedia.org/wiki/Portable_Executable)と呼ばれる形式で、MSDNの[こちら](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format)で説明されています。PEは、有名なマジックバイト "MZ "で始まる特定のヘッダフォーマットを持ち、その他のフィールドについては[こちら](https://wiki.osdev.org/MZ)で説明されています。しかし、通常、ほとんどのPEファイルの最初の0x3Cバイトは同一です。ですから、私たちは、その辺に転がっている実行ファイル(`MBCrackme.exe`のような)からこれらの最初のバイトを既知の平文として受け取り、暗号文とXORして鍵を得ることができます。


with open("MBCrackme.exe", "rb") as fp:
    known\_plaintext \= fp.read(0x3C)

print(xor(ciphertext, known\_plaintext)\[:0x3C\])

と入力すると、`b'easy_level_one_almost_done_xor_pe_and_keep_going!easy_level_'`となり、キーがはっきりとわかります。

## Level 2

Now that we have our level 1 key, we can dump out the decrypted executable for analysis.

plaintext \= xor(ciphertext, b"easy\_level\_one\_almost\_done\_xor\_pe\_and\_keep\_going!")
with open('level2.exe', 'wb') as fp:
    fp.write(plaintext)

Opening the file in CFF explorer, we see that it is not a .NET binary (sadly), so we have to look it in IDA to find out what it does.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_4.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_4.png)

For the subsequent analysis in IDA, we will use a [base address](https://docs.oracle.com/cd/E19683-01/817-3677/chapter6-37/index.html) of `0x400000` when referring to subroutine addresses. By default, the base address should be loaded at that memory address, the reasons for which are explained in [this article](https://devblogs.microsoft.com/oldnewthing/20141003-00/?p=43923). However, when debugging, the base address may shift to some other location like `0x1A0000` (usually because of [ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization), which we can check if it's enabled [with CFF explorer](https://security.stackexchange.com/a/43682)), and this would cause all the addresses in our IDA database to be out of sync with the ones in this writeup. To change the base address that IDA uses to calculate the addresses, we can select "Edit"->"Segments"->"Rebase Program" under the menu bar.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_5.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_5.png)

### Main

We start our analysis at the main function at `0x401070`, which first calls `AddVectoredExceptionHandler` to register the function at `0x401000` (which IDA has renamed `Handler` for us) as a [vectored exception handler](https://docs.microsoft.com/en-us/windows/win32/debug/vectored-exception-handling). We will examine what this `Handler` function does later when its use comes into play, but for now we will continue looking at what the main function does after that.

The main function then calls `memset()` to zero out `0x4E4B2` bytes of a stack variable that IDA has labelled `Src`, then calls `sub_4011D0` with the following arguments

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_6.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_6.png)

`unk_414000` is a memory location in the `.data` section that contains strange data

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_7.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_7.png)

### sub\_4011D0

If we look into `sub_4011D0`, we see that it gets the address of the [PEB](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm), then traverses the linked list in the structure to get one of the loaded modules (DLL) in the process. Then, it passes the loaded module and a weird number `985953233` to the function `sub_401250` which would return some sort of function, and that returned function is called afterwards with most of the original arguments.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_8.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_8.png)

Even without looking into `sub_401250`, this behavior already looks very similar to [API hashing](https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware), a technique used to obfuscate API calls, which makes static analysis difficult because we can't directly see which APIs are being called. It is a popular technique used by real malwares like [Dridex](https://securityintelligence.com/protected-api-calls-and-string-constants-looting-dridexs-candy-box/), or [Cobalt Strike](https://decoded.avast.io/threatintel/decoding-cobalt-strike-understanding-payloads/), and it works by passing a API hash and a reference to a loaded module to an API resolving function (in this case `sub_401250`), which would go through all the exported APIs from that module, hash the names of the APIs, then compare it against the given hash. If the resolver function finds an API which matches the given hash, it returns the address of that API.

Just so we have a clearer picture of what's going on before we analyze the resolver function `sub_401250`, we refer to some documentation (the structure is partially undocumented on [MSDN](https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data) so we have to refer to [other sources](https://www.vergiliusproject.com/kernels/x86/Windows%20XP/SP3/_LDR_DATA_TABLE_ENTRY)) and find that `Flink` actually should have the pointer type `_LDR_DATA_TABLE_ENTRY *`, so we change the type (by pressing "Y") and find that `v8` is from the field `DllBase` which points to the base address of the loaded module.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_9.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_9.png)

### sub\_401250

Now we can analyze `sub_401250` with the correct pointer types (e.g. `IMAGE_DOS_HEADER *` for `a1`). After some renaming and cleaning up, we see the following code which represents the hashing algorithm

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_10.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_10.png)

There are a few methods we can use to find out which APIs are being resolved.

The first uses dynamic analysis, where we just step over the API resolver function to see which API got resolved. This would probably be easier in our case, but sometimes it can be more troublesome especially if there are many resolved API calls or if extensive anti-debugging techniques are present.

The second method would be to re-implement the resolver function, which would allow us to know which APIs correspond to which hashes statically. This method also gives us the flexibility to write an [IDAPython](https://hex-rays.com/products/ida/support/idapython_docs/) script to automatically resolve all calls within the binary if there are many such calls inside and resolving them individually would be too tedious.

Note that there are also existing tools like [HashDB](https://hashdb.openanalysis.net/) that you could explore, but we won't be using them today.

We would write something like this to re-implement the resolver function

import pefile

def rol4(x, n):
  return ((x << n) | (x \>> (32 \- n))) & 0xFFFFFFFF

def hash\_name(function\_name):
    hash\_value \= 0xF00DF00D
    for b in function\_name:
        hash\_value \= (rol4(hash\_value, 5) ^ b) & 0xFFFFFFFF
    return hash\_value

entry\_export \= \[pefile.DIRECTORY\_ENTRY\["IMAGE\_DIRECTORY\_ENTRY\_EXPORT"\]\]
exports \= \[\]
libraries \= \[
    'ntdll',
    'kernel32',
    'gdi32',
    'user32',
    'comctl32',
    'comdlg32',
    'ws2\_32',
    'advapi32',
    'netapi32',
    'ole32',
    'winmm',
    'imm32',
    'bcrypt',
    'wmi',
\]

for library in libraries:
    pe \= pefile.PE(f'C:/windows/system32/{library}.dll')
    pe.parse\_data\_directories(directories\=entry\_export)
    exports += \[e.name for e in pe.DIRECTORY\_ENTRY\_EXPORT.symbols if e.name\]
    print(exports\[\-1\])

hash\_to\_name \= {hash\_name(name):name for name in exports}

So now we have a dictionary `hash_to_name` that acts like the API resolver. If we give it our original hash `985953233`, we find that it actually resolves to `RtlDecompressBuffer`.

\>>\> hash\_to\_name\[985953233\]
b'RtlDecompressBuffer'

Now that we know the API called, we realize that `sub_4011D0` is in fact just a wrapper for `RtlDecompressBuffer` with the options `COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM`, meaning that it just decompresses the 160345-byte buffer at `unk_414000` using the [LZNT1](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-xca/5655f4a3-6ba4-489b-959f-e1f407c52f15) algorithm, and places it into the stack variable `Src`.

To extract the decompressed bytes, we run it dynamically by stepping over the call to `RtlDecompressBuffer`, then find the address of the output buffer (`0x8F19DC` in this case) and extract the file with the following IDAPython code

a \= ida\_bytes.get\_bytes(0x8F19DC, 320690)
open('decompressed\_buf\_2.bin', 'wb').write(a)

### Back to main

Continuing with our analysis of main, after it decompresses the buffer, it makes another hash-resolved API call with a different hash `0xF4DD3DAD`

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_11.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_11.png)

Our re-implemented resolver tells us that this is `NtAllocateVirtualMemory`

\>>\> hash\_to\_name\[0xF4DD3DAD\]
b'NtAllocateVirtualMemory'

and after some cleaning up, we can see that the decompressed data is run as code, telling us that the decompressed data is shellcode

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_12.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_12.png)

However, when we take a look at the decompressed data in a hex editor, we find that it is a whole PE file with all the "MZ" and "PE" headers and not just some shellcode.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_13.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_13.png)

This is strange because loaders (`level2.exe` in this case) would normally have to do some PE header parsing to find the entry point before transferring control over, but this loader directly transfers control to the start of the file which is where the "MZ" header is at. If we run the loader dynamically and step into the call to the PE file, we find that the "MZ" header actually contains some valid instructions

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_14.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_14.png)

If we take a closer look at the MZ header and do some digging online, we find [this tool](https://github.com/hasherezade/pe_to_shellcode) by [hasherezade](https://twitter.com/hasherezade) (the challenge author) which modifies a PE structure to make the header executable and move the reflective loading code into the PE itself, effectively "shellcodifying" the PE file, which is pretty neat. The MZ header of our decompressed PE file is very similar to the [source code](https://github.com/hasherezade/pe_to_shellcode/blob/master/pe2shc/main.cpp) of this tool, which tells us that it's very likely this tool was used.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_15.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_15.png) [![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_16.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_16.png)

The main function just returns after the call to the shellcode / PE file, so we can conclude that the role of `level2.exe` is simply a loader that decompresses and loads a shellcodified PE file, and later analysis tells us that this PE file acts as some sort of server, so we will call it `server.exe`.

### Analyzing server.exe

This binary is also not a .NET application, so we have to look at it in IDA again.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_17.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_17.png)

The main function allocates some memory, then calls `sub_405E10`, then `sub_4061E0` with 2 arguments, one looking like a pipe name and the other being the number 1337, and lastly `sub_4092A6` which just calls free.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_18.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_18.png)

Luckily for us, the API calls are not obfuscated like in the loader was so analysis is slightly easier.

### sub\_405E10 - Anti-debugging

`sub_405E10` first places 34 DWORDs into an array in the stack, then calls `sub_405CB0` for each one of them.

If we look at the code in `sub_405CB0`, it seems to be accessing some structure, and choosing which field to access based on some comparison. This behavior is a clue to us that there might be some sort of [binary search tree (BST)](https://en.wikipedia.org/wiki/Binary_search_tree) structure involved here, since when we are searching for elements in a BST, we have to compare the current node against our search value then pick either the left or right nodes, which would be represented by different fields in our structure. More information about BSTs can be found [here](https://visualgo.net/en/bst?slide=1).

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_19.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_19.png)

In addition, `sub_405CB0` calls `sub_405B50` which contains the string `"map/set<T> too long"`, which is a smoking gun telling us that this is part of some C++ standard library function, more specifically `std::set<int>`. This [set container](https://www.cplusplus.com/reference/set/set/) uses a [balanced binary tree](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree) to store its items internally. Rolf Rolles published an [article](https://www.msreverseengineering.com/blog/2021/9/21/automation-in-reverse-engineering-c-template-code) which talks about reversing STL containers, which we can reference to create this struct

struct bbt\_node
{
  bbt\_node \*left;
  bbt\_node \*parent;
  bbt\_node \*right;
  char field\_C;
  char is\_terminal;
  \_BYTE gap\_E\[2\];
  int data;
};

and also conclude that `sub_405CB0` is `std::set::insert()`, and that `off_437E9C` points to a `std::set` which contains the 34 numbers.

After adding the numbers to the set, it checks if any of the functions `sub_402520`, `sub_402560()`, or `sub_402320` returns 1, and if so executes the instruction `int 3` which triggers a breakpoint exception.

The first function `sub_402520` is relatively simple, only calling `IsDebuggerPresent()` and `IsRemoteDebuggerPresent()` to check for any debuggers attached.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_20.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_20.png)

The second function `sub_402560` calls `IsBadReadPtr(0x7FFE0000, 0x3B8)`, then checks if `0x7FFE02D4` is set. A bit of searching gives us this [very similar function](https://github.com/hasherezade/antianalysis_demos/blob/master/kernelmode_antidbg.cpp) (also from the challenge author), which tells us that `0x7FFE0000` is the address to the structure [KUSER\_SHARED\_DATA](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi_x/kuser_shared_data/index.htm). This means that `0x7FFE02D4` (offset `0x2D4`) corresponds to the field `KdDebuggerEnabled`. This function just checks if a debugger is present.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_21.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_21.png)

The last function `sub_402320` takes the argument `off_437E9C`, which is our `std::set` structure. If we look inside, it calls `CreateToolhelp32Snapshot` then `Process32First`. After that, it takes the field `szExeFile` (which contains the name of the executable file that the process is running without the `.exe` extension) and runs this hash algorithm, which is almost identical to the one used in the API hashing method, the only difference being the initial hash value and the fact that this one hashes the lowercased string.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_22.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_22.png)

Afterwards, it searches for the hash value in our set, and returns true if found. Then it calls `Process32Next` then does the same thing in a loop. The function essentially scans the system for blacklisted processes, the hashes of which are found in the 34 numbers in our set. We can guess that the hashes are of analysis or sandbox tools, and this technique of evading analysis via system checks is used by [real world malware](https://attack.mitre.org/techniques/T1497/001/), like [ObliqueRAT](https://blog.talosintelligence.com/2021/02/obliquerat-new-campaign.html) which has an analysis process blacklist, or [PlugX](https://unit42.paloaltonetworks.com/unit42-paranoid-plugx/) which checks for processes named "vmtoolsd".

Note that this function calls `sub_4013E0` and `sub_4014D0` which are both related to `std::string`. We know this because there are a lot of comparisons of some offset with the number 16, which is a byproduct of the [short string optimization](https://blogs.msmvps.com/gdicanio/2016/11/17/the-small-string-optimization/) used by MSVC. The structure for `std::string` can be represented something like this (taken from Eleemosynator's [writeup](https://github.com/eleemosynator/writeups/blob/master/mb_crackme_2/readme.md) for the previous Malwarebytes crackme)

// Simplified layout of the std::string object
struct string\_layout {
union contents\_union {
charbuffer\[16\];
char\*data;
}contents;// offset 0x00
size\_tsize;// offset 0x10
size\_treserved;// offset 0x14
} ;

### About that handler function

We now know that the three functions were just checking for signs of debugging, but it is still strange why it would execute `int 3` if it detected debugging. To answer this, we have to bring our attention back to the VEH `Handler` function in the loader `level2.exe`.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_23.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_23.png)

If the exception code is an access violation then they output a failure message box and terminate the process. If the exception address within the loaded binary, and the exception is a breakpoint, then they terminate the process, which means that the `int 3` instruction was just to terminate the process via the exception handler.

### Back to server.exe

We now know that `sub_405E10` is an anti-debugging function that terminates the process if debugging is detected. The next function called is `sub_4061E0`, which first creates a [named mutex](https://docs.microsoft.com/en-us/windows/win32/sync/mutex-objects) `MB_Crackme_level2_mutex`, and returns if it isn't able to create it. Real world malwares [do this too](https://www.sans.org/blog/looking-at-mutex-objects-for-malware-discovery-indicators-of-compromise/), usually to ensure that only a single instance of the program is running.

Afterwards, it initializes the values in a structure in the stack with 2 fields, the pipe name and the address of `sub_406290`. We will label the fields in the struct as such

struct thread\_struct
{
  int value;
  int subroutine;
};

Then it calls `sub_4051E0` which creates a thread at `sub_405210`, passing in that struct as its parameters. It also calls `sub_405A80` which creates another thread with the same struct with different values, but that part is for level 3 so we will focus on `sub_405210` first.

`sub_405210` calls `CreateNamedPipeA` to create a new [named pipe](https://docs.microsoft.com/en-us/windows/win32/ipc/pipes) at `\\.\pipe\crackme_pipe`, then reads from it, then creates a thread to `sub_4032C0`, then immediately waits for the thread to close, so it's basically a function call. `sub_4032C0` reads from the pipe, then calls `sub_406290` which it got from its thread struct argument. The result of calling `sub_406290` is then written back to the same pipe, then it cleans up and closes itself.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_24.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_24.png)

`sub_406290` hashes the string that was written to the pipe with the same hashing algorithm as the one used in the anti-debug-blacklisted-process-checking-function `sub_402320`, then checks if its in the set at `off_437E9C` which is the same set containing those 34 blacklisted process name hashes. If it is, it uses the string as an [RC4](https://en.wikipedia.org/wiki/RC4) key to decrypt the following 29-byte-long string (repesented in hex), then returns the decrypted string (to get written back to the pipe)

```
5a9558f17c6d62b5c2c68ad620f2f610d88fef4cd663468b1a0dbea251
```

We know its RC4 because it calls the function `sub_401200` which contains this block of code that creates the substitution box

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_25.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_25.png)

which is a tell-tale sign of RC4, and we can find the [KSA](https://en.wikipedia.org/wiki/RC4#Key-scheduling_algorithm_(KSA)) and [PRGA](https://en.wikipedia.org/wiki/RC4#Pseudo-random_generation_algorithm_(PRGA)) after analyzing the rest of the function. More information about how to recognize RC4 constructs can be found in [this video](https://www.youtube.com/watch?v=CiJocXXMXK4) by OALabs.

### Button 2

To find out what gets written into the pipe and what happens to the decrypted data, we have to switch our focus back to the original .NET executable `MBCrackme.exe`, at `button2_Click`.

private void button2\_Click(object sender, EventArgs e)
{
if (this.textBox2.Text.Length \== 0)
{
MessageBox.Show("Enter the password!");
return;
}
bool flag \= false;
string pipeName \= "crackme\_pipe";
string text \= this.textBox2.Text;
byte\[\] array \= null;
try
{
NamedPipeClientStream namedPipeClientStream \= new NamedPipeClientStream(".", pipeName);
namedPipeClientStream.Connect(1000);
StreamWriter streamWriter \= new StreamWriter(namedPipeClientStream);
TextReader textReader \= new StreamReader(namedPipeClientStream);
streamWriter.WriteLine(text);
streamWriter.Flush();
string s \= textReader.ReadLine();
array \= Encoding.ASCII.GetBytes(s);
if (Crc32Algorithm.Compute(array) \== Form1.validCrc32\_2)
{
flag \= true;
}
}
// Exception and GUI handling...

It connects to the pipe and writes the level 2 password to it, then reads from it and checks if the CRC32 checksum of the response is equal to `Form1.validCrc32_2`, which is `0x1DC85E5D`.

This means that the pipe serves as a communication channel between `server.exe` and `MBCrackme.exe`.

Tip: if you want to debug the application and write to the pipe, it takes only 5 lines to do it in powershell

$npipeClient \= new-object System.IO.Pipes.NamedPipeClientStream('.', 'crackme\_pipe')
$npipeClient.Connect()
$pipeWriter \= new-object System.IO.StreamWriter($npipeClient)
$pipeWriter.Write('stuff to write to the pipe')
$pipeWriter.Flush() 

### Mapping hashes to analysis processes

To summarize what we know so far,

1.  There are 34 names of analysis processes that it compares hashes against
2.  The level 2 password is one of the analysis process names, but might not be lowercase itself
3.  The password is used as the RC4 key to decrypt a 29-byte long stack string
4.  The RC4 decrypted string has a CRC32 checksum of `0x1DC85E5D` (after removing the trailing null byte)

Hence, to find out what the level 2 password could be, we have to first find out what processes are being blacklisted. To do this, we will take the executable names of as many analysis processes as we can, then hash their names and check if their hashes match any of the 34.

We can start with gathering all executable files on our system with this powershell line. Our flare-vm environment comes with many analysis tools that could give us a hit, so this is worth a shot.

Get-ChildItem \*.exe \-Recurse \-Path C:\\ | % { echo $\_.BaseName } \> executables.txt

This [Github repo](https://github.com/LordNoteworthy/al-khaser#antivm) also contains the names of some analysis processes, so we format it (remove the `.exe` extension) and add it to our list `executables.txt`.

We write a script to test the hashes

def rol4(x, n):
    return ((x << n) | (x \>> (32 \- n))) & 0xFFFFFFFF

def hash\_name(text, initial\_hash\_value):
        hash\_value \= initial\_hash\_value
        for b in text:
                hash\_value \= (rol4(hash\_value, 5) ^ b) & 0xFFFFFFFF
        return hash\_value

HASHES \= \[
    0xC81D63C9, 0x5B2839AC, 0x17DAD73F, 0x72C7241C,
    0x58E483ED, 0x82134662, 0x34204667, 0x4CD53A71,
    0x34206499, 0xFFDEB191, 0x7AC6410B, 0xEA3503AA,
    0xCCFA2924, 0x3A09FFBC, 0x38EA0C1B, 0x58E479EC,
    0x1B964E1A, 0x707F9D9A, 0xF5A79701, 0x09F5473B,
    0xBA635AC6, 0x0BB18A65, 0x46119FD8, 0xFB7BF6AF,
    0x3F75D54B, 0x49110E9F, 0x5D9F9FD8, 0x5DCC9FD8,
    0x8293C33E, 0x5D112314, 0x9D9F8189, 0xC10AE786,
    0x67D8B725, 0x07FE9020,
\]

with open('executables.txt', 'r') as fp:
executables \= fp.read().split()

executables \= list(set(executables))

hash\_to\_name \= {}

for executable in executables:
processed\_name \= executable.lower().encode()
hash\_value \= hash\_name(processed\_name, 0xBADC0FFE)
hash\_to\_name\[hash\_value\] \= executable

for hash\_value in HASHES:
    if hash\_value in hash\_to\_name:
        print(hex(hash\_value), hash\_to\_name\[hash\_value\])
    else:
        print(hex(hash\_value, "not found")

We run it and get this mapping

```
> python .\match_hashes.py
0xc81d63c9 ollydbg
0x5b2839ac ProcessHacker
0x17dad73f tcpview
0x72c7241c autoruns
0x58e483ed autorunsc
0x82134662 filemon
0x34204667 procmon
0x4cd53a71 regmon
0x34206499 procexp
0xffdeb191 idaq
0x7ac6410b idaq64
0xea3503aa ImmunityDebugger
0xccfa2924 Wireshark
0x3a09ffbc dumpcap
0x38ea0c1b HookExplorer
0x58e479ec ImportREC
0x1b964e1a PETools
0x707f9d9a LordPE
0xf5a79701 SysInspector
0x9f5473b proc_analyzer
0xba635ac6 sysAnalyzer
0xbb18a65 sniff_hit
0x46119fd8 windbg
0xfb7bf6af joeboxcontrol
0x3f75d54b joeboxserver
0x49110e9f ResourceHacker
0x5d9f9fd8 x32dbg
0x5dcc9fd8 x64dbg
0x8293c33e Fiddler
0x5d112314 httpdebugger
0x9d9f8189 Vmwaretray
0xc10ae786 pe-sieve
0x67d8b725 hollows_hunter
0x7fe9020 pin
```

We then try each of them and see if it matches the CRC32 checksum, using this script

import Crypto.Cipher.ARC4
import zlib

possible\_passwords \= \[
    "ollydbg", "ProcessHacker", "tcpview", "autoruns", 
    "autorunsc", "filemon", "procmon", "regmon", 
    "procexp", "idaq", "idaq64", "ImmunityDebugger", 
    "Wireshark", "dumpcap", "HookExplorer", "ImportREC", 
    "PETools", "LordPE", "SysInspector", "proc\_analyzer", 
    "sysAnalyzer", "sniff\_hit", "windbg", "joeboxcontrol", 
    "joeboxserver", "ResourceHacker", "x32dbg", "x64dbg", 
    "Fiddler", "httpdebugger", "Vmwaretray", "pe-sieve", 
    "hollows\_hunter", "pin", 
\]

\# Try lowercase too
possible\_passwords += \[s.lower() for s in possible\_passwords\]

ciphertext \= bytes.fromhex("5a9558f17c6d62b5c2c68ad620f2f610d88fef4cd663468b1a0dbea251")

for password in possible\_passwords:
    \# RC4 requires a password length of at least 5
    if len(password) < 5:
        continue
    cipher \= Crypto.Cipher.ARC4.new(password.encode())
    decrypted\_string \= cipher.decrypt(ciphertext).rstrip(b'\\x00')
    if zlib.crc32(decrypted\_string) \== 0x1DC85E5D:
        print("Found match!")
        print(f"Password: {password}")
        print(f"Decrypted: {decrypted\_string}")

Running it gives us

```
> python .\find_password.py
Found match!
Password: ProcessHacker
Decrypted: b'we_are_good_to_go_to_level3!'
```

So we now know that the password for level 2 is `ProcessHacker`. We are good to go to level 3!

Quite a lot happened, so we have this figure to summarize this level

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_26.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_26.png)

## Level 3

Now that we know what the server writes to the pipe, we can shift our attention back to the original `MBCrackme.exe`. Looking at the last part of `button2_Click`, it calls `LoadNext.Load`.

// button2\_Click continued
if (flag)
{
this.button2.Enabled \= false;
this.textBox2.Enabled \= false;
this.button2.BackColor \= Color.OldLace;
this.button3.Enabled \= true;
this.textBox3.Enabled \= true;
this.button3.BackColor \= SystemColors.ActiveCaption;
MessageBox.Show("Level up!");
LoadNext.Load(Form1.g\_serverProcess, array);
return;
}

This method takes `LoadNext.EncArr`, then performs [base64](https://en.wikipedia.org/wiki/Base64) decoding on it, then AES decryption (using the returned string `we_are_good_to_go_to_level3!` from level 2), then [gzip](https://en.wikipedia.org/wiki/Gzip) decompression (`LoadNext.DecompressBytes`), before loading it using `Assembly.Load` and running the `RunMe` method under some `Level3Bin.Class1` class.

public static int Load(Process process1, byte\[\] password)
{
try
{
Type type \= Assembly.Load(LoadNext.DecompressBytes(AES.decryptContent(Convert.FromBase64String(LoadNext.EncArr), password))).GetType("Level3Bin.Class1");
object obj \= Activator.CreateInstance(type);
Type\[\] types \= new Type\[\]
{
typeof(Process)
};
MethodInfo method \= type.GetMethod("RunMe", types);
object\[\] parameters \= new object\[\]
{
process1
};
method.Invoke(obj, parameters);
}
// Exception handling...

This tells us that the decoded content after all those steps is some .NET binary.

`AES.decryptContent` uses a salt and the returned password to generate an AES key and IV using [PBKDF2](https://datatracker.ietf.org/doc/html/rfc2898#section-5.2), then uses [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) [CBC](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)) mode to decrypt the content.

public static byte\[\] decryptContent(byte\[\] fileContent, byte\[\] password)
{
MemoryStream memoryStream \= new MemoryStream();
byte\[\] password2 \= SHA256.Create().ComputeHash(password);
byte\[\] salt \= new byte\[\]
{
5,
3,
3,
7,
8,
0,
0,
8
};
RijndaelManaged rijndaelManaged \= new RijndaelManaged();
rijndaelManaged.KeySize \= 256;
rijndaelManaged.BlockSize \= 128;
Rfc2898DeriveBytes rfc2898DeriveBytes \= new Rfc2898DeriveBytes(password2, salt, 1000);
rijndaelManaged.Key \= rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
rijndaelManaged.IV \= rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
rijndaelManaged.Mode \= CipherMode.CBC;
try
{
CryptoStream cryptoStream \= new CryptoStream(memoryStream, rijndaelManaged.CreateDecryptor(), CryptoStreamMode.Write);
cryptoStream.Write(fileContent, 0, fileContent.Length);
cryptoStream.FlushFinalBlock();
cryptoStream.Close();
}
// Exception handling...

We want to decrypt the content, but the base64 string is too long to view completely in dnSpy, and it gives the `[...string is too long...]"` message at the end, so to get the whole string, we have to right click and select "Edit IL instructions"

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_27.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_27.png)

This way we can have access to the whole string under `ldstr`

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_28.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_28.png)

Afterwards we save it in a file called `b64_encoded_string.txt`, and write the following script to get the decoded data

import base64
import gzip
import hashlib
import Crypto.Cipher.AES
import Crypto.Util.Padding
import Crypto.Protocol.KDF

with open('b64\_encoded\_string.txt', 'r') as fp:
    text \= fp.read()

encrypted\_data \= base64.b64decode(text)
salt \= bytes(\[5, 3, 3, 7, 8, 0, 0, 8\])
password \= b'we\_are\_good\_to\_go\_to\_level3!'
password \= hashlib.sha256(password).digest()
rfc\_2898\_bytes \= Crypto.Protocol.KDF.PBKDF2(password, salt, dkLen\=48)

aes\_key \= rfc\_2898\_bytes\[:32\]
aes\_iv \= rfc\_2898\_bytes\[32:\]

aes\_cipher \= Crypto.Cipher.AES.new(aes\_key, Crypto.Cipher.AES.MODE\_CBC, aes\_iv)
compressed\_data \= aes\_cipher.decrypt(encrypted\_data)
compressed\_data \= Crypto.Util.Padding.unpad(compressed\_data, Crypto.Cipher.AES.block\_size)

actual\_data \= gzip.decompress(compressed\_data)

with open('decrypted\_data.bin', 'wb') as fp:
fp.write(actual\_data)

### Decrypted DLL

The decrypted data turns out to be a DLL file, and is a .NET binary like we suspected

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_29.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_29.png)

We rename the file `level3.dll`, then put it in dnSpy for analysis. We look at the function `RunMe` first because that's what's called by `MBCrackme.exe`.

public static int RunMe(Process process1)
{
try
{
string tempFileName \= Class1.GetTempFileName("dat");
if (Class1.DropTheDll(tempFileName))
{
DllInj.InjectToProcess(process1, tempFileName);
}
}
catch (IOException ex)
{
MessageBox.Show(ex.Message, "Error!", MessageBoxButtons.OK, MessageBoxIcon.Hand);
}
return 0;
}

`Class1.DropTheDll` just drops a DLL file into a `.dat` file in the temp directory with a random file name, then `DllInj.InjectToProcess` injects the DLL into the `server.exe` process. This technique is called [DLL injection](https://attack.mitre.org/techniques/T1055/001/), and is frequently used by real malware, examples of which can be found in that link.

public static int InjectToProcess(Process targetProcess, string dllName)
{
IntPtr hProcess \= DllInj.OpenProcess(1082, false, targetProcess.Id);
IntPtr procAddress \= DllInj.GetProcAddress(DllInj.GetModuleHandle("kernel32.dll"), "LoadLibraryA");
IntPtr intPtr \= DllInj.VirtualAllocEx(hProcess, IntPtr.Zero, (uint)((dllName.Length + 1) \* Marshal.SizeOf(typeof(char))), 12288U, 4U);
UIntPtr uintPtr;
DllInj.WriteProcessMemory(hProcess, intPtr, Encoding.Default.GetBytes(dllName), (uint)((dllName.Length + 1) \* Marshal.SizeOf(typeof(char))), out uintPtr);
DllInj.CreateRemoteThread(hProcess, IntPtr.Zero, 0U, procAddress, intPtr, 0U, IntPtr.Zero);
return 0;
}

### Injected DLL

CFF explorer tells us that the injected DLL is not a .NET binary, so we will analyze it in IDA

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_30.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_30.png)

Here we will use `0x10000000` as the base address when referring to addresses.

This DLL doesn't have any exports, only a `DllMain`.

Looking at the segments, we see two unusual segments `.detourc` and `.detourd` which are not standard in normal PE files. This will be useful later.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_31.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_31.png)

The DLL when loaded outputs a debug message saying it is hooking some process, and during unloading outputs another debug string saying that it is unhooks the process.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_32.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_32.png)

`sub_10004D00` seems to be acquiring some lock, then calls `sub_10004520` which calls `VirtualProtect` to change the permissions of some memory block to RWX.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_33.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_33.png)

`sub_10005260` suspends the thread it takes as the argument if it's not the current thread

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_34.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_34.png)

`sub_10004570` is a wrapper for `sub_10004590`, and takes in 2 arguments, one being some global variable and the other being some function. If we cross-reference the global variables (pressing "X" in IDA), we can see that `dword_1002AE60` points to `CryptStringToBinaryA` (initialized in `sub_10001000`), `dword_1002AE64` points to `GetCursorPos` (initialized in `sub_10001010`), and `dword_1002AE68` points to `Sleep` (initialized in `sub_10001020`). The initialization functions were all called in `dllmain_crt_process_attach`, which is run before `DllMain` is run.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_35.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_35.png)

Within `sub_10004590`, it calls many functions that check for certain `jmp` or `nop` opcodes in the subroutine given in the global variable, like `sub_100049F0` that calls `sub_100043C0` which gets a jump destination relative to the first instruction, or `sub_10003BA0` which checks returns the size of the first instruction if it is a `nop` or `int 3`.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_36.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_36.png)

This behavior suggests that some sort of [API hooking](https://resources.infosecinstitute.com/topic/api-hooking/) is happening, more specifically [inline hooking](https://www.malwaretech.com/2015/01/inline-hooking-for-programmers-part-1.html), because the hook function would have to check the API function's instructions to set up the trampoline properly and sure that the program doesn't crash.

If we search online for any information for the `.detourc` and `.detourd` sections, we can find an instrumentation library by Microsoft called [Detours](https://github.com/microsoft/Detours) that uses inline hooking. If we do more digging, we can find [this](https://github.com/hasherezade/detours_cmake_tpl/blob/master/project_tpl/main.cpp), written by the challenge author, with the following example usage code

void hook\_apis()
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&(PVOID&)pMessageBoxA, my\_MessageBoxA);
    DetourTransactionCommit();
}

void unhook\_apis()
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourDetach(&(PVOID&)pMessageBoxA, my\_MessageBoxA);
    DetourTransactionCommit();
}

It seems that `sub_10004D00` is `DetourTransactionBegin`, `sub_10005260` is `DetourUpdateThread`, and `sub_10004570` is `DetourAttach`. This gives us even more confirmation that this DLL performs inline hooking. We will explore the modified behavior of the functions later when it comes into play.

### Button 3

For now, we will turn our attention back to the original binary `MBCrackme.exe`, specifically `button3_Click`.

TcpClient tcpClient \= new TcpClient("127.0.0.1", 1337);
byte\[\] array \= Encoding.ASCII.GetBytes(this.textBox3.Text);
NetworkStream stream \= tcpClient.GetStream();
stream.Write(array, 0, array.Length);
array \= new byte\[256\];
string text \= string.Empty;
int count \= stream.Read(array, 0, array.Length);
text \= Encoding.ASCII.GetString(array, 0, count);
if (text.Length \> 10)
{
this.label4.Text \= text;
this.button3.BackColor \= Color.OldLace;
this.textBox3.Enabled \= false;
this.button3.Enabled \= false;
}
MessageBox.Show(text); 

It connects and writes the third password to the localhost TCP [socket](https://en.wikipedia.org/wiki/Network_socket) at port 1337, then receives back the reply and places it in the message box.

### Server yet again

To find out how the listening socket gets set up and what gets written to it, we have to revisit `server.exe`, and take a look at the other thread at `sub_4056F0` that was created by `sub_405A80` which is called by `sub_4061E0`. It first creates a socket and prepares the structures to point to the socket address `127.0.0.1:1337`.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_37.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_37.png)

Then it binds that address to the socket and listens on it

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_38.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_38.png)

When it accepts a connection, it calls `sub_406530`, which first prepares the following 68-byte long stack string (in hex representation)

```
7FB19BA3DBB87A983EE96B2FACC4405A420F905F5CF19CAB32791BF50CCAA306C4454A4AF61D592141DAF3C7BAEFEEA32D0D82451735D334CBDCC3D7B35B5EFA673FE269EF02415A
```

Afterwards, it takes the submitted password, then calls `CryptStringToBinaryA` with `CRYPT_STRING_BASE64` as the `dwFlags` option.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_39.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_39.png)

Then, it takes the decoded string (in `pbBinary`) and for every byte, calls `GetCursorPos` and then compares the `x` value against the decoded byte rotated

1.  left or right depending on whether the index is even or odd, and
2.  by how much depending on the `y` value returned

If the comparison succeeds, it sets the value of the decoded text to the original byte rotated the other way by the same amount.

Then, it calls `Sleep`.

Afterwards, it takes the resultant value of the decoded text as an RC4 key (using the same RC4 function `sub_401200` used in level 2)

This seems arbitrary because the cursor position could really be anywhere, but remember that these three APIs were hooked in the injected DLLs, so it's time to analyze how their behavior changes after being hooked.

### Proxy functions

The proxy function (the function whose code is run instead of the hooked function) for `CryptStringToBinaryA` is `sub_10002990` (from the injected DLL). It outputs some debug strings about the arguments, then calls the real `CryptStringToBinaryA`. Afterwards, it sets a global variable, which we will call `g_counter`, to `4`.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_40.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_40.png)

`sub_10002B10` is the proxy function for `GetCursorPos`. It doesn't actually call the real `GetCursorPos` function, but instead returns the `x` and `y` values as bytes from the arrays `byte_1002A000` and `byte_1002A020` based on the value of `g_counter`.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_41.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_41.png)

The arrays contain non-ASCII values

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_42.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_42.png) [![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_43.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_43.png)

`sub_10002B60` is the proxy function for `Sleep`, and it simply increments `g_counter`.

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_44.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_44.png)

Taken together, this means that the processing of the decoded base64 string is not arbitrary, but actually has nothing to do with our mouse position and is in fact deterministic.

### Finding our flag

Turning our attention back to the password processing function `sub_4056F0` inside `server.exe`, we will assume that the comparison of the rotated byte to the `x` value matches every time (if it doesn't, then the decoded byte can take any other value, which leaves us with no information). So, we will find the value of the decoded bytes that passes all the checks using a bit of algebra.

We will call the index `i`, the decoded byte `ciphertext[i]`, and the new value set `plaintext[i]`. For even `i`, if the comparison were to succeed, we have to have

```
rol(ciphertext[i], y_val % 8) == x_val
plaintext[i] == ror(ciphertext[i], y_val % 8)
```

We can rotate right both sides of the first line to get

```
ciphertext[i] == ror(x_val, y_val % 8)
```

and then substitute it in the second line to get

```
plaintext[i] == ror(ror(x_val, y_val % 8), y_val % 8)
```

and since rotating right by the same value twice is the same as rotating right by twice the value,

```
 plaintext[i] == ror(x_val, (y_val * 2) % 8)
```

For odd `i`, it's just `rol` instead of `ror`.

With that, we can write the following python script to get the plaintext

x\_array \= \[
    0x95, 0xb9, 0x63, 0x59, 0xdc, 0xb5, 0x58, 0xc6,
    0x6c, 0x5f, 0x68, 0x6f, 0x6f, 0xad, 0xdc, 0x5f,
    0x6d, 0x58, 0xda, 0x65, 0x5f, 0x58, 0xd7, 0x62,
    0x69, 0x9d, 0xd7, 0x91, 0x96, 0x99, 0x66, 0x65,
    0x9c,
\]

y\_array \= \[
    0x83, 0x1b, 0x89, 0x20, 0x37, 0x8b, 0x57, 0xc6,
    0x78, 0x74, 0x00, 0xc4, 0x48, 0x83, 0xdb, 0x7c,
    0x48, 0x49, 0x8b, 0x48, 0xf8, 0x49, 0xff, 0x24,
    0x74, 0x93, 0x53, 0x03, 0x4a, 0x03, 0xc0, 0x48,
\]

def rol(x, n):
    return ((x << n) | (x \>> (8 \- n))) & 0xFF

def ror(x, n):
    return ((x \>> n) | (x << (8 \-n))) & 0xFF

ans \= \[\]
counter \= 4
for i in range(33):
    x\_val \= x\_array\[counter % 33\]
    y\_val \= y\_array\[counter % 32\]
    if i % 2 \== 0:
        plaintext \= ror(x\_val, (2 \* y\_val) % 8)
    else:
        plaintext \= rol(x\_val, (2 \* y\_val) % 8)
    ans.append(plaintext)
    counter += 1

print(bytes(ans))

which gives `b'small_hooks_make_a_big_difference'`.

And to get the flag, we just use it at the RC4 key to decrypt the stack string

import Crypto.Cipher.ARC4

password \= b'small\_hooks\_make\_a\_big\_difference'
ciphertext \= bytes.fromhex("7FB19BA3DBB87A983EE96B2FACC4405A420F905F5CF19CAB32791BF50CCAA306C4454A4AF61D592141DAF3C7BAEFEEA32D0D82451735D334CBDCC3D7B35B5EFA673FE269EF02415A")

cipher \= Crypto.Cipher.ARC4.new(password)
decrypted\_string \= cipher.decrypt(ciphertext).rstrip(b'\\x00')

print(decrypted\_string)

giving us `flag{you_got_this_best_of_luck_in_reversing_and_beware_of_red_herrings}`.

This figure summarizes what happened in this level

[![](https://github.com/JLeow00/malwarebytes-crackme-3/raw/main/images/figure_45.png)](https://github.com/JLeow00/malwarebytes-crackme-3/blob/main/images/figure_45.png)

### What was the third password

Even though we already got the flag, I want to briefly go through what were the possible values for the third password, for the sake of completeness.

There are actually a lot of valid values of the password here. The only condition for it to be correct was it decoded to `small_hooks_make_a_big_difference` after all the rotating. This means that if we base64 encode that string itself, i.e. `c21hbGxfaG9va3NfbWFrZV9hX2JpZ19kaWZmZXJlbmNl`, then that would be a valid password. We could also have rotated the bytes and let the check correct it for us, so something like `ua2wsWz1aPZvbZv1bbBbZV+wryaW7PqMpcxmZZOs3GOy` would also work.

Note that any of the bytes in our password can be either from the decoded string (`small_hooks_make_a_big_difference`) or be rotated, which gives 2 possibilities per byte. Since the password has 33 characters, this gives 2 to the power of 33 (8589934592) possible values for password #3.

## Conclusion

In this crackme, we saw techniques like

-   Steganography
-   Vectored exception handling
-   API hash obfuscation
-   "Shellcodified" PE files
-   Anti-debugging system checks
-   RC4 encryption
-   The use of pipes and network sockets for inter process communication
-   DLL injection
-   Inline hooking

While analyzing all of them wasn't strictly necessary for getting the flag, they are used in real malware so there is utility in understanding how they are used. In addition, the code wasn't obfuscated much so this is a good place to get exposed to these techniques. Kudos to hasherezade for setting up this challenge!

## Flag

```
flag{you_got_this_best_of_luck_in_reversing_and_beware_of_red_herrings}
```